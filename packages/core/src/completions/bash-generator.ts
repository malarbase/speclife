/**
 * Bash completion script generator
 */

import type { CompletionGenerator, CommandDef, ArgDef, OptionDef } from './types.js';
import { getConfigKeys } from './commands.js';

export class BashGenerator implements CompletionGenerator {
  readonly shell = 'bash' as const;
  
  generate(commands: CommandDef[]): string {
    const lines: string[] = [
      '# Bash completion for speclife',
      '# Generated by speclife completion bash',
      '',
      '_speclife_complete_change_id() {',
      '  local changes',
      '  changes=$(speclife list --json 2>/dev/null | grep -o \'"id":"[^"]*"\' | cut -d\'"\'  -f4)',
      '  COMPREPLY=($(compgen -W "$changes" -- "${COMP_WORDS[COMP_CWORD]}"))',
      '}',
      '',
      '_speclife_complete_config_key() {',
      `  local keys="${getConfigKeys().join(' ')}"`,
      '  COMPREPLY=($(compgen -W "$keys" -- "${COMP_WORDS[COMP_CWORD]}"))',
      '}',
      '',
      '_speclife() {',
      '  local cur prev words cword',
      '  _init_completion || return',
      '',
      '  local commands="' + commands.map(c => c.name).join(' ') + '"',
      '',
      '  # Handle first argument (main command)',
      '  if [[ $cword -eq 1 ]]; then',
      '    COMPREPLY=($(compgen -W "$commands" -- "$cur"))',
      '    return',
      '  fi',
      '',
      '  local cmd="${words[1]}"',
      '',
    ];
    
    // Generate case for each command
    lines.push('  case "$cmd" in');
    
    for (const cmd of commands) {
      lines.push(...this.generateCommandCase(cmd));
    }
    
    lines.push('  esac');
    lines.push('}');
    lines.push('');
    lines.push('complete -F _speclife speclife');
    lines.push('');
    
    return lines.join('\n');
  }
  
  getInstallInstructions(): string {
    return `# Add to your ~/.bashrc or ~/.bash_profile:
speclife completion bash >> ~/.bashrc
source ~/.bashrc

# Or install system-wide (requires sudo):
speclife completion bash | sudo tee /etc/bash_completion.d/speclife`;
  }
  
  private generateCommandCase(cmd: CommandDef): string[] {
    const lines: string[] = [];
    
    lines.push(`    ${cmd.name})`);
    
    if (cmd.subcommands && cmd.subcommands.length > 0) {
      lines.push('      if [[ $cword -eq 2 ]]; then');
      lines.push(`        COMPREPLY=($(compgen -W "${cmd.subcommands.map(s => s.name).join(' ')}" -- "$cur"))`);
      lines.push('        return');
      lines.push('      fi');
      lines.push('      local subcmd="${words[2]}"');
      lines.push('      case "$subcmd" in');
      
      for (const sub of cmd.subcommands) {
        lines.push(`        ${sub.name})`);
        lines.push(...this.generateArgCompletion(sub.args ?? [], sub.options ?? [], 6));
        lines.push('          ;;');
      }
      
      lines.push('      esac');
    } else {
      lines.push(...this.generateArgCompletion(cmd.args ?? [], cmd.options ?? [], 4));
    }
    
    lines.push('      ;;');
    
    return lines;
  }
  
  private generateArgCompletion(args: ArgDef[], options: OptionDef[], indent: number): string[] {
    const pad = ' '.repeat(indent);
    const lines: string[] = [];
    
    // Collect all options
    const optionWords = options.flatMap(o => [o.short, o.long].filter(Boolean)).join(' ');
    
    // Handle option completions
    if (options.length > 0) {
      lines.push(`${pad}case "$prev" in`);
      for (const opt of options.filter(o => o.takesValue)) {
        const pattern = [opt.short, opt.long].filter(Boolean).join('|');
        lines.push(`${pad}  ${pattern})`);
        lines.push(...this.generateValueCompletion(opt, indent + 4));
        lines.push(`${pad}    return`);
        lines.push(`${pad}    ;;`);
      }
      lines.push(`${pad}esac`);
    }
    
    // If current word starts with -, complete options
    lines.push(`${pad}if [[ "$cur" == -* ]]; then`);
    lines.push(`${pad}  COMPREPLY=($(compgen -W "${optionWords}" -- "$cur"))`);
    lines.push(`${pad}  return`);
    lines.push(`${pad}fi`);
    
    // Otherwise complete positional args
    for (const arg of args) {
      if (arg.completion === 'change-id') {
        lines.push(`${pad}_speclife_complete_change_id`);
        break;
      } else if (arg.completion === 'config-key') {
        lines.push(`${pad}_speclife_complete_config_key`);
        break;
      } else if (arg.completion === 'static' && arg.staticValues) {
        lines.push(`${pad}COMPREPLY=($(compgen -W "${arg.staticValues.join(' ')}" -- "$cur"))`);
        break;
      } else if (arg.completion === 'file') {
        lines.push(`${pad}COMPREPLY=($(compgen -f -- "$cur"))`);
        break;
      } else if (arg.completion === 'directory') {
        lines.push(`${pad}COMPREPLY=($(compgen -d -- "$cur"))`);
        break;
      }
    }
    
    return lines;
  }
  
  private generateValueCompletion(opt: OptionDef, indent: number): string[] {
    const pad = ' '.repeat(indent);
    
    if (opt.valueCompletion === 'static' && opt.staticValues) {
      return [`${pad}COMPREPLY=($(compgen -W "${opt.staticValues.join(' ')}" -- "$cur"))`];
    } else if (opt.valueCompletion === 'change-id') {
      return [`${pad}_speclife_complete_change_id`];
    } else if (opt.valueCompletion === 'config-key') {
      return [`${pad}_speclife_complete_config_key`];
    } else if (opt.valueCompletion === 'file') {
      return [`${pad}COMPREPLY=($(compgen -f -- "$cur"))`];
    } else if (opt.valueCompletion === 'directory') {
      return [`${pad}COMPREPLY=($(compgen -d -- "$cur"))`];
    }
    
    return [];
  }
}

