/**
 * Zsh completion script generator
 */

import type { CompletionGenerator, CommandDef, ArgDef, OptionDef } from './types.js';
import { getConfigKeys } from './commands.js';

export class ZshGenerator implements CompletionGenerator {
  readonly shell = 'zsh' as const;
  
  generate(commands: CommandDef[]): string {
    const lines: string[] = [
      '#compdef speclife',
      '# Zsh completion for speclife',
      '# Generated by speclife completion zsh',
      '',
      '_speclife_change_ids() {',
      '  local changes',
      '  changes=($(speclife list --json 2>/dev/null | grep -o \'"id":"[^"]*"\' | cut -d\'"\' -f4))',
      '  _describe "change" changes',
      '}',
      '',
      '_speclife_config_keys() {',
      `  local keys=(${getConfigKeys().join(' ')})`,
      '  _describe "config key" keys',
      '}',
      '',
      '_speclife() {',
      '  local -a commands',
      '  commands=(',
      ...commands.map(c => `    '${c.name}:${this.getCommandDescription(c)}'`),
      '  )',
      '',
      '  _arguments -C \\',
      '    "1: :->command" \\',
      '    "*::arg:->args"',
      '',
      '  case "$state" in',
      '    command)',
      '      _describe "command" commands',
      '      ;;',
      '    args)',
      '      case "$words[1]" in',
    ];
    
    for (const cmd of commands) {
      lines.push(...this.generateCommandCase(cmd));
    }
    
    lines.push('      esac');
    lines.push('      ;;');
    lines.push('  esac');
    lines.push('}');
    lines.push('');
    lines.push('_speclife "$@"');
    lines.push('');
    
    return lines.join('\n');
  }
  
  getInstallInstructions(): string {
    return `# Add to your ~/.zshrc:
speclife completion zsh >> ~/.zshrc
source ~/.zshrc

# Or install to fpath:
speclife completion zsh > ~/.zsh/completions/_speclife
# Then ensure ~/.zsh/completions is in your fpath`;
  }
  
  private getCommandDescription(cmd: CommandDef): string {
    const descriptions: Record<string, string> = {
      init: 'Initialize SpecLife in this project',
      worktree: 'Manage git worktrees',
      status: 'Show change status',
      list: 'List all changes',
      view: 'Show dashboard view',
      completion: 'Generate shell completions',
      config: 'Manage configuration',
      validate: 'Validate change spec',
      update: 'Update managed files',
      version: 'Show version',
    };
    return descriptions[cmd.name] ?? cmd.name;
  }
  
  private generateCommandCase(cmd: CommandDef): string[] {
    const lines: string[] = [];
    
    lines.push(`        ${cmd.name})`);
    
    if (cmd.subcommands && cmd.subcommands.length > 0) {
      lines.push('          local -a subcommands');
      lines.push('          subcommands=(');
      for (const sub of cmd.subcommands) {
        lines.push(`            '${sub.name}:${this.getSubcommandDescription(cmd.name, sub.name)}'`);
      }
      lines.push('          )');
      lines.push('          _arguments -C \\');
      lines.push('            "1: :->subcommand" \\');
      lines.push('            "*::arg:->subargs"');
      lines.push('          case "$state" in');
      lines.push('            subcommand)');
      lines.push('              _describe "subcommand" subcommands');
      lines.push('              ;;');
      lines.push('            subargs)');
      lines.push('              case "$words[1]" in');
      
      for (const sub of cmd.subcommands) {
        lines.push(`                ${sub.name})`);
        lines.push(...this.generateArgsSpec(sub.args ?? [], sub.options ?? [], 18));
        lines.push('                  ;;');
      }
      
      lines.push('              esac');
      lines.push('              ;;');
      lines.push('          esac');
    } else {
      lines.push(...this.generateArgsSpec(cmd.args ?? [], cmd.options ?? [], 10));
    }
    
    lines.push('          ;;');
    
    return lines;
  }
  
  private getSubcommandDescription(cmd: string, sub: string): string {
    const descriptions: Record<string, Record<string, string>> = {
      worktree: {
        create: 'Create a worktree for a change',
        rm: 'Remove a worktree',
        list: 'List all worktrees',
      },
      config: {
        path: 'Show config file path',
        list: 'List all config values',
        get: 'Get a config value',
        set: 'Set a config value',
        unset: 'Remove a config value',
        reset: 'Reset to defaults',
        edit: 'Open config in editor',
      },
    };
    return descriptions[cmd]?.[sub] ?? sub;
  }
  
  private generateArgsSpec(args: ArgDef[], options: OptionDef[], indent: number): string[] {
    const pad = ' '.repeat(indent);
    const lines: string[] = [];
    
    lines.push(`${pad}_arguments \\`);
    
    // Add options
    for (const opt of options) {
      const flags = [opt.short, opt.long].filter(Boolean);
      const spec = flags.length > 1 
        ? `{${flags.join(',')}}`
        : flags[0];
      
      if (opt.takesValue) {
        const valueSpec = this.getZshValueSpec(opt);
        lines.push(`${pad}  '${spec}[${opt.description}]:${opt.long?.replace('--', '')}:${valueSpec}' \\`);
      } else {
        lines.push(`${pad}  '${spec}[${opt.description}]' \\`);
      }
    }
    
    // Add positional args
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      const pos = i + 1;
      const valueSpec = this.getZshArgSpec(arg);
      const optional = arg.optional ? ':' : '';
      lines.push(`${pad}  '${optional}${pos}:${arg.name}:${valueSpec}' \\`);
    }
    
    // Remove trailing backslash from last line
    if (lines.length > 1) {
      lines[lines.length - 1] = lines[lines.length - 1].replace(/ \\$/, '');
    }
    
    return lines;
  }
  
  private getZshValueSpec(opt: OptionDef): string {
    if (opt.valueCompletion === 'static' && opt.staticValues) {
      return `(${opt.staticValues.join(' ')})`;
    } else if (opt.valueCompletion === 'change-id') {
      return '_speclife_change_ids';
    } else if (opt.valueCompletion === 'config-key') {
      return '_speclife_config_keys';
    } else if (opt.valueCompletion === 'file') {
      return '_files';
    } else if (opt.valueCompletion === 'directory') {
      return '_directories';
    }
    return '';
  }
  
  private getZshArgSpec(arg: ArgDef): string {
    if (arg.completion === 'static' && arg.staticValues) {
      return `(${arg.staticValues.join(' ')})`;
    } else if (arg.completion === 'change-id') {
      return '_speclife_change_ids';
    } else if (arg.completion === 'config-key') {
      return '_speclife_config_keys';
    } else if (arg.completion === 'file') {
      return '_files';
    } else if (arg.completion === 'directory') {
      return '_directories';
    }
    return '';
  }
}

