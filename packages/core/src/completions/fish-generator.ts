/**
 * Fish completion script generator
 */

import type { CompletionGenerator, CommandDef, OptionDef } from './types.js';
import { getConfigKeys } from './commands.js';

export class FishGenerator implements CompletionGenerator {
  readonly shell = 'fish' as const;
  
  generate(commands: CommandDef[]): string {
    const lines: string[] = [
      '# Fish completion for speclife',
      '# Generated by speclife completion fish',
      '',
      '# Disable file completion by default',
      'complete -c speclife -f',
      '',
      '# Helper functions',
      'function __speclife_change_ids',
      '  speclife list --json 2>/dev/null | string match -r \'"id":"[^"]*"\' | string replace -r \'"id":"([^"]*)"\' \'$1\'',
      'end',
      '',
      'function __speclife_config_keys',
      `  echo "${getConfigKeys().join('\\n')}"`,
      'end',
      '',
      '# Main commands',
    ];
    
    for (const cmd of commands) {
      const desc = this.getCommandDescription(cmd);
      lines.push(`complete -c speclife -n "__fish_use_subcommand" -a "${cmd.name}" -d "${desc}"`);
    }
    
    lines.push('');
    
    for (const cmd of commands) {
      lines.push(`# ${cmd.name} subcommands and options`);
      lines.push(...this.generateCommandCompletions(cmd));
      lines.push('');
    }
    
    return lines.join('\n');
  }
  
  getInstallInstructions(): string {
    return `# Save to Fish completions directory:
speclife completion fish > ~/.config/fish/completions/speclife.fish

# Or use mkdir if directory doesn't exist:
mkdir -p ~/.config/fish/completions
speclife completion fish > ~/.config/fish/completions/speclife.fish`;
  }
  
  private getCommandDescription(cmd: CommandDef): string {
    const descriptions: Record<string, string> = {
      init: 'Initialize SpecLife in this project',
      worktree: 'Manage git worktrees',
      status: 'Show change status',
      list: 'List all changes',
      view: 'Show dashboard view',
      completion: 'Generate shell completions',
      config: 'Manage configuration',
      validate: 'Validate change spec',
      update: 'Update managed files',
      version: 'Show version',
    };
    return descriptions[cmd.name] ?? cmd.name;
  }
  
  private generateCommandCompletions(cmd: CommandDef): string[] {
    const lines: string[] = [];
    const condition = `__fish_seen_subcommand_from ${cmd.name}`;
    
    if (cmd.subcommands && cmd.subcommands.length > 0) {
      // Add subcommand completions
      for (const sub of cmd.subcommands) {
        const desc = this.getSubcommandDescription(cmd.name, sub.name);
        lines.push(`complete -c speclife -n "${condition}; and not __fish_seen_subcommand_from ${cmd.subcommands.map(s => s.name).join(' ')}" -a "${sub.name}" -d "${desc}"`);
      }
      
      // Add options for each subcommand
      for (const sub of cmd.subcommands) {
        const subCondition = `${condition}; and __fish_seen_subcommand_from ${sub.name}`;
        lines.push(...this.generateOptions(sub.options ?? [], subCondition));
        lines.push(...this.generateArgs(sub, subCondition));
      }
    } else {
      // Add options for the command
      lines.push(...this.generateOptions(cmd.options ?? [], condition));
      lines.push(...this.generateArgs(cmd, condition));
    }
    
    return lines;
  }
  
  private getSubcommandDescription(cmd: string, sub: string): string {
    const descriptions: Record<string, Record<string, string>> = {
      worktree: {
        create: 'Create a worktree for a change',
        rm: 'Remove a worktree',
        list: 'List all worktrees',
      },
      config: {
        path: 'Show config file path',
        list: 'List all config values',
        get: 'Get a config value',
        set: 'Set a config value',
        unset: 'Remove a config value',
        reset: 'Reset to defaults',
        edit: 'Open config in editor',
      },
    };
    return descriptions[cmd]?.[sub] ?? sub;
  }
  
  private generateOptions(options: OptionDef[], condition: string): string[] {
    const lines: string[] = [];
    
    for (const opt of options) {
      let completion = `complete -c speclife -n "${condition}"`;
      
      if (opt.short) {
        completion += ` -s ${opt.short.replace('-', '')}`;
      }
      if (opt.long) {
        completion += ` -l ${opt.long.replace('--', '')}`;
      }
      
      completion += ` -d "${opt.description}"`;
      
      if (opt.takesValue) {
        completion += ' -r';
        if (opt.valueCompletion === 'static' && opt.staticValues) {
          completion += ` -a "${opt.staticValues.join(' ')}"`;
        } else if (opt.valueCompletion === 'change-id') {
          completion += ' -a "(__speclife_change_ids)"';
        } else if (opt.valueCompletion === 'config-key') {
          completion += ' -a "(__speclife_config_keys)"';
        }
      }
      
      lines.push(completion);
    }
    
    return lines;
  }
  
  private generateArgs(cmd: CommandDef, condition: string): string[] {
    const lines: string[] = [];
    
    for (const arg of cmd.args ?? []) {
      if (arg.completion === 'change-id') {
        lines.push(`complete -c speclife -n "${condition}" -a "(__speclife_change_ids)"`);
      } else if (arg.completion === 'config-key') {
        lines.push(`complete -c speclife -n "${condition}" -a "(__speclife_config_keys)"`);
      } else if (arg.completion === 'static' && arg.staticValues) {
        lines.push(`complete -c speclife -n "${condition}" -a "${arg.staticValues.join(' ')}"`);
      } else if (arg.completion === 'file') {
        lines.push(`complete -c speclife -n "${condition}" -F`);
      } else if (arg.completion === 'directory') {
        lines.push(`complete -c speclife -n "${condition}" -a "(__fish_complete_directories)"`);
      }
    }
    
    return lines;
  }
}

